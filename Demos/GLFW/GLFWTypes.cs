namespace Nori;
using static GLFW;

#region Enumerations -------------------------------------------------------------------------------
// Describes the connection status of monitors, joysticks etc
enum ConnectionStatus { Unknown = 0x0, Connected = 0x40001, Disconnected = 0x40002 }

// Which type of rendering API should be initialized
enum ClientApi { None = 0x0, OpenGL = 0x30001, OpenGLES = 0x30002 }

// Error codes returned by GLFW
enum ErrorCode {
   None = 0x0,                      // No error
   NotInitialized = 0x10001,     // GLFW not initialized
   NoCurrentContext = 0x10002,   // No GL context on the current thread
   InvalidEnum = 0x10003,        // One of the arguments to a function was an invalid enum value
   InvalidValue = 0x10004,       // One of the arguments to the function was an invalid value
   OutOfMemory = 0x10005,        // Memory allocation failed
   ApiUnavailable = 0x10006,     // GLFW could not find support for the requested API
   VersionUnavailable = 0x10007, // Requested OpenGL version (including required hints) is not available
   PlatformError = 0x10008,      // Platform-specific error occured
   FormatUnavailable = 0x10009,  // Required PIXEL format / Clipboard format not supported
   NoWindowContext = 0x1000A     // Windows passed to a function does not have an OpenGL context
}

// Various types of OpenGL profile
public enum GLProfile { Any = 0x0, Core = 0x32001, Compatibility = 0x32002 }

// Various hints related to creating a Window
enum Hint {
   Focused = 0x20001,                  // Is window focused on creation? (default = Constants.True)
   Resizable = 0x20003,                // Is window resizeable? (default = true)
   Visible = 0x20004,                  // Is window visible? (default = true)
   Decorated = 0x20005,                // Is Window decorated with chrome (default = true)
   AutoIconify = 0x20006,              // Will a full screen automatically iconify on losing focus
   Floating = 0x20007,                 // Specicies always-on-top window (default = false)
   Maximized = 0x20008,                // Will window be maximized when created (default = false)
   RedBits = 0x21001,                  // Bit depth of red component of the default framebuffer (default = 8)
   GreenBits = 0x21002,                // Bit depth of green component of the default framebuffer (default = 8)
   BlueBits = 0x21003,                 // Bit depth of the blue component of default framebuffer (default = 8)
   AlphaBits = 0x21004,                // Bit depth of alpha component of default framebuffer (default = 8)
   DepthBits = 0x21005,                // Specified bit-depth of depth buffer (default = 24)
   StencilBits = 0x21006,              // Bit depth of stencil buffer (default = 8)
   Stereo = 0x2100c,                   // Use stereoscopic rendering (default = false)
   Samples = 0x2100d,                  // Desired number of samples to use for multisampling (zero disables)
   SrgbCapable = 0x2100e,              // Should framebuffer be sRGB capable (default = false)
   Doublebuffer = 0x21010,             // Should framebuffer be double-buffered (default = true_
   RefreshRate = 0x2100f,              // Refresh rate for full-screen windows
   ClientApi = 0x22001,                // Specifies the client api to use (default = ClientApi.OpenGL)
   ContextCreationApi = 0x2200b,       // Specifies context creation API to use (default = ContexApi.Native)
   ContextVersionMajor = 0x22002,      // API major version that the created context must be compatible with (default = 1)
   ContextVersionMinor = 0x22003,      // API minor version that the created context should be compatible with (default = 0)
   ContextRobustness = 0x22005,        // Specifies robustness strategy to use
   OpenglForwardCompatible = 0x22006,  // Is the GL context forward compatible
   OpenglDebugContext = 0x22007,       // Create a Debug context?
   OpenglProfile = 0x22008,            // Which OpenGL profile to use
   ContextReleaseBehavior = 0x22009,   // Release behavior to be used by the context
   ContextNoError = 0x2200a,           // Should errors be generated by the context
   CocoaChDirResources = 0x51001,      // See GLFW documentation (only for Mac)
   CocoaMenuBar = 0x51002,             // Create a menu bar?
   CenterCursor = 0x20009,             // Should cursor be centered over newly created full-screen windows?
   TransparentFramebuffer = 0x2000A,   // Is window framebuffer transparent?
   FocusOnShow = 0x2000C,              // Is window given input focus when ShowWindow is called?
   ScaleToMonitor = 0x2200C,           // Should window content area be resized based on monitor content scale
   CocoaRetinaFrameBuffer = 0x23001,   // Use full resolution framebuffer on Retina displays?
   CocoaFrameName = 0x23002,           // UTF8 encoded name to ue for saving window frame
   CocoaGraphicsSwitching = 0x23003,   // Opt-in for Automatic Graphics switching
   X11ClassName = 0x24001,             // ASCII encoded class parts of the ICCCM window property
   X11InstanceName = 0x24002           // ASCII encoded instance parts of the ICCCM window property
}

// Window attributes used for GetWindowAttr
public enum EWindowAttr {
   Focused = 0x20001,         // Is window focused?
   AutoIconify = 0x20002,     // Will full-screen-window automatically iconify on losing focus?
   Maximized = 0x20008,       // Is window maximized when created?
   Visible = 0x20004,         // Is window visible?
   Resizable = 0x20003,       // Is window resizeable
   Decorated = 0x20005,       // Is window decorated?
   Floating = 0x20007,        // Is window always-on-top
   MouseHover = 0x2000B       // Is mouse over the window
}

enum HMonitor : ulong { None };
enum HWindow : ulong { None };
enum HString : ulong { Zero };
#endregion

#region class Monitor ------------------------------------------------------------------------------
/// <summary>This is a wrapper around a GLFW monitor</summary>
public readonly struct Monitor {
   // Properties ---------------------------------------------------------------
   /// <summary>Returns a list of all the connected monitors</summary>
   public static Monitor[] All {
      get {
         var monitors = GetMonitors (out int cMonitors);
         Monitor[] all = new Monitor[cMonitors];
         for (int i = 0; i < cMonitors; i++)
            all[i] = new (Marshal.PtrToStructure<HMonitor> (monitors + i * Marshal.SizeOf<nint> ()));
         return all;
      }
   }

   /// <summary>Is this the 'none' monitor</summary>
   public bool IsNone => mHMonitor == HMonitor.None;

   /// <summary>The name of the monitor</summary>
   public string Name => Marshal.PtrToStringUTF8 ((nint)GetMonitorName (mHMonitor)) ?? "";

   /// <summary>Represents 'no monitor'</summary>
   public static Monitor None = new ();

   /// <summary>Position of the upper-left corner of the specified monitor</summary>
   public (int X, int Y) Position {
      get { GetMonitorPosition (mHMonitor, out int x, out int y); return (x, y); }
   }

   /// <summary>The primary monitor connected to this computer</summary>
   public static Monitor Primary => new (GetPrimaryMonitor ());

   /// <summary>Content scale of the current monitor (ratio between current DPI and platform default DPI)</summary>
   public (double X, double Y) Scale {
      get { GetMonitorContentScale (mHMonitor, out float x, out float y); return (x, y); }
   }

   /// <summary>Returns information about the current video mode of this monitor</summary>
   public ModeInfo VideoMode
      => Marshal.PtrToStructure<ModeInfo> (GetVideoMode (mHMonitor));

   /// <summary>Get the position, in screen coordinates, of the valid work area for the monitor</summary>
   public (int X, int Y, int Width, int Height) WorkArea {
      get {
         GetMonitorWorkArea (mHMonitor, out int x, out int y, out int width, out int height);
         return (x, y, width, height);
      }
   }

   // Events -------------------------------------------------------------------
   /// <summary>Subscribe to this event to know when a monitor is connected or disconnected</summary>
   public static event Action<Monitor, bool> Changed {
      add {
         if (!mConnected) { SetMonitorCallback (OnMonitorChanged); mConnected = true; }
         mChanged += value;
      }
      remove => mChanged -= value;
   }
   static bool mConnected;
   static event Action<Monitor, bool>? mChanged;

   static void OnMonitorChanged (HMonitor monitor, ConnectionStatus connect)
      => mChanged?.Invoke (new Monitor (monitor), connect == ConnectionStatus.Connected);

   // Nested types -------------------------------------------------------------
   [StructLayout (LayoutKind.Explicit, Size = 24, Pack = 4)]
   public readonly struct ModeInfo {
      [FieldOffset (0)] public readonly int Width;
      [FieldOffset (4)] public readonly int Height;
      [FieldOffset (8)] public readonly int RedBits;
      [FieldOffset (12)] public readonly int GreenBits;
      [FieldOffset (16)] public readonly int BlueBits;
      [FieldOffset (20)] public readonly int RefreshRate;
   }

   // Implementation -----------------------------------------------------------
   internal Monitor (HMonitor handle) => mHMonitor = handle;
   readonly HMonitor mHMonitor;
}
#endregion
